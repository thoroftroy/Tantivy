import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon, FancyArrowPatch
from matplotlib.lines import Line2D
import matplotlib.patches as mpatches
import random

# === USER CONFIGURATION ===
map_width = 30
map_height = 20
output_size = (12, 8)  # in inches
output_dpi = 300
output_filename = "hex_map_with_compass.png"
hex_radius = 1

# Biomes and their visuals
biomes = {
    'forest': {'closed_sides': 2, 'color': '#006400'},     # Dark green
    'plains': {'closed_sides': 1, 'color': '#7CFC00'},     # Light green
    'mountains': {'closed_sides': 3, 'color': '#A9A9A9'},  # Gray
    'pond': {'closed_sides': 0, 'color': '#1E90FF'},       # Blue
    'city': {'closed_sides': 0, 'color': '#B22222'},       # Red
}

# City names
city_names = [
    "Thornhelm", "Ravenmoor", "Elderholt", "Stonefield", "Windmere",
    "Frostbrook", "Ironvale", "Brightwatch", "Duskwater", "Oakshade"
]

# Perlin noise
def generate_perlin_noise_2d(shape, res):
    def f(t): return 6 * t**5 - 15 * t**4 + 10 * t**3
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]].transpose(1, 2, 0) % 1
    angles = 2 * np.pi * np.random.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    g00 = gradients[0:-1, 0:-1]
    g10 = gradients[1:, 0:-1]
    g01 = gradients[0:-1, 1:]
    g11 = gradients[1:, 1:]
    n00 = np.sum(grid * g00.repeat(d[0], 0).repeat(d[1], 1), 2)
    n10 = np.sum(np.dstack((grid[:, :, 0]-1, grid[:, :, 1])) * g10.repeat(d[0], 0).repeat(d[1], 1), 2)
    n01 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1]-1)) * g01.repeat(d[0], 0).repeat(d[1], 1), 2)
    n11 = np.sum(np.dstack((grid[:, :, 0]-1, grid[:, :, 1]-1)) * g11.repeat(d[0], 0).repeat(d[1], 1), 2)
    t = f(grid)
    n0 = n00 * (1 - t[:, :, 0]) + t[:, :, 0] * n10
    n1 = n01 * (1 - t[:, :, 0]) + t[:, :, 0] * n11
    return np.sqrt(2) * ((1 - t[:, :, 1]) * n0 + t[:, :, 1] * n1)

def classify_biome(value):
    if value < 0.4:
        return 'plains'
    elif value < 0.7:
        return 'forest'
    else:
        return 'mountains'

def hex_coordinates(row, col, radius):
    x = col * 3/2 * radius
    y = np.sqrt(3) * radius * (row + 0.5 * (col % 2))
    return (x, y)

def get_closed_edges(biome):
    count = biomes[biome]['closed_sides']
    return np.random.choice(6, size=count, replace=False)

def edge_to_vertices(center, radius, edge):
    angle_offset = np.pi / 6
    angle1 = 2 * np.pi * (edge / 6) + angle_offset
    angle2 = 2 * np.pi * ((edge + 1) % 6) + angle_offset
    x1 = center[0] + radius * np.cos(angle1)
    y1 = center[1] + radius * np.sin(angle1)
    x2 = center[0] + radius * np.cos(angle2)
    y2 = center[1] + radius * np.sin(angle2)
    return (x1, y1), (x2, y2)

def add_ponds(noise_map, chance=0.01):
    pond_map = np.zeros_like(noise_map, dtype=bool)
    for r in range(1, noise_map.shape[0]-1):
        for c in range(1, noise_map.shape[1]-1):
            if random.random() < chance and noise_map[r, c] < 0.6:
                pond_map[r, c] = True
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        if 0 <= r+dr < pond_map.shape[0] and 0 <= c+dc < pond_map.shape[1]:
                            if random.random() < 0.4:
                                pond_map[r+dr, c+dc] = True
    return pond_map

def add_cities(noise_map, count=10):
    city_coords = []
    attempts = 0
    while len(city_coords) < count and attempts < 500:
        r, c = random.randint(0, map_height-1), random.randint(0, map_width-1)
        biome = classify_biome(noise_map[r, c])
        if biome in ['plains', 'forest'] and (r, c) not in city_coords:
            city_coords.append((r, c))
        attempts += 1
    return city_coords

# Generate noise and features
res_x = max(1, map_width // 5)
res_y = max(1, map_height // 5)
noise = generate_perlin_noise_2d((map_height, map_width), (res_y, res_x))
noise = (noise - noise.min()) / (noise.max() - noise.min())
pond_mask = add_ponds(noise)
city_coords = add_cities(noise, count=len(city_names))

# Plot map
fig, ax = plt.subplots(figsize=output_size)
ax.set_aspect('equal')
placed_cities = []

for row in range(map_height):
    for col in range(map_width):
        center = hex_coordinates(row, col, hex_radius)
        if (row, col) in city_coords:
            biome = 'city'
            placed_cities.append((center, city_names[len(placed_cities)]))
        elif pond_mask[row, col]:
            biome = 'pond'
        else:
            biome = classify_biome(noise[row, col])

        color = biomes[biome]['color']
        hex_patch = RegularPolygon(center, numVertices=6, radius=hex_radius,
                                   orientation=np.radians(30), edgecolor='black', facecolor=color)
        ax.add_patch(hex_patch)

        closed_edges = get_closed_edges(biome)
        for edge in closed_edges:
            start, end = edge_to_vertices(center, hex_radius, edge)
            ax.add_line(Line2D([start[0], end[0]], [start[1], end[1]], color='red', linewidth=2))

# Label cities
for (x, y), name in placed_cities:
    ax.text(x, y, name, fontsize=6, color='white', ha='center', va='center', fontweight='bold')

# Add legend
legend_handles = [
    mpatches.Patch(color=biomes[key]['color'], label=key.capitalize())
    for key in ['plains', 'forest', 'mountains', 'pond', 'city']
]
legend = ax.legend(handles=legend_handles, loc='upper right', frameon=True)

# Add compass near legend
arrow_x = map_width * 1.35
arrow_y = map_height * 0.2
ax.add_patch(FancyArrowPatch((arrow_x, arrow_y), (arrow_x, arrow_y + 1.5),
                             mutation_scale=20, color='black'))
ax.text(arrow_x, arrow_y + 1.6, 'N', ha='center', va='bottom',
        fontsize=12, fontweight='bold')

# Finalize and save
ax.autoscale_view()
ax.axis('off')
plt.tight_layout()
plt.savefig(output_filename, dpi=output_dpi, bbox_inches='tight')
plt.close()
print(f"Map saved as '{output_filename}'")
