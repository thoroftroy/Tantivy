import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon, FancyArrowPatch
from matplotlib.lines import Line2D
import matplotlib.patches as mpatches
import random

# === CONFIGURATION ===
map_width = 30
map_height = 20
hex_radius = 1
output_dpi = 100
output_filename = "hex_map_with_compass.png"
output_size = (map_width * 3, map_height * 1.5)

# Biome settings
biomes = {
    'forest': {'closed_sides': 2, 'color': '#006400'},
    'plains': {'closed_sides': 1, 'color': '#7CFC00'},
    'mountains': {'closed_sides': 3, 'color': '#A9A9A9'},
    'pond': {'closed_sides': 0, 'color': '#1E90FF'},
    'city': {'closed_sides': 0, 'color': '#B22222'},
}

city_names = [
    "Thornhelm", "Ravenmoor", "Elderholt", "Stonefield", "Windmere",
    "Frostbrook", "Ironvale", "Brightwatch", "Duskwater", "Oakshade"
]

def generate_perlin_noise_2d(shape, res):
    def f(t): return 6*t**5 - 15*t**4 + 10*t**3
    delta = (res[0]/shape[0], res[1]/shape[1])
    d = (shape[0]//res[0], shape[1]//res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]].transpose(1,2,0)%1
    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    g00, g10, g01, g11 = gradients[:-1,:-1], gradients[1:,:-1], gradients[:-1,1:], gradients[1:,1:]
    n00 = np.sum(grid * g00.repeat(d[0],0).repeat(d[1],1), 2)
    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1])) * g10.repeat(d[0],0).repeat(d[1],1), 2)
    n01 = np.sum(np.dstack((grid[:,:,0], grid[:,:,1]-1)) * g01.repeat(d[0],0).repeat(d[1],1), 2)
    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11.repeat(d[0],0).repeat(d[1],1), 2)
    t = f(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)

def classify_biome(value):
    if value < 0.4: return 'plains'
    elif value < 0.7: return 'forest'
    else: return 'mountains'

def hex_coordinates(row, col, radius):
    x = col * 1.5 * radius
    y = np.sqrt(3) * radius * (row + 0.5 * (col % 2))
    return (x, y)

def get_closed_edges(biome):
    count = biomes[biome]['closed_sides']
    return set(np.random.choice(6, size=1 if biome == 'city' else count, replace=False))

def edge_to_vertices(center, radius, edge):
    angle_offset = np.pi / 6
    a1 = 2 * np.pi * (edge / 6) + angle_offset
    a2 = 2 * np.pi * ((edge + 1) % 6) + angle_offset
    return (
        (center[0] + radius * np.cos(a1), center[1] + radius * np.sin(a1)),
        (center[0] + radius * np.cos(a2), center[1] + radius * np.sin(a2))
    )

def add_ponds(noise, chance=0.01):
    mask = np.zeros_like(noise, dtype=bool)
    for r in range(1, noise.shape[0]-1):
        for c in range(1, noise.shape[1]-1):
            if random.random() < chance and noise[r,c] < 0.6:
                mask[r,c] = True
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if 0 <= r+dr < noise.shape[0] and 0 <= c+dc < noise.shape[1]:
                            if random.random() < 0.4:
                                mask[r+dr, c+dc] = True
    return mask

def add_cities(noise, count=10):
    coords = []
    attempts = 0
    while len(coords) < count and attempts < 500:
        r, c = random.randint(0, map_height-1), random.randint(0, map_width-1)
        if classify_biome(noise[r,c]) in ['plains', 'forest']:
            if (r, c) not in coords:
                coords.append((r, c))
        attempts += 1
    return coords

# Generate terrain
noise = generate_perlin_noise_2d((map_height, map_width), (max(1,map_height//5), max(1,map_width//5)))
noise = (noise - noise.min()) / (noise.max() - noise.min())
pond_mask = add_ponds(noise)
city_coords = add_cities(noise, len(city_names))

# Assign biomes and edge variants
tile_biomes = np.empty((map_height, map_width), dtype=object)
tile_closed_edges = np.empty((map_height, map_width), dtype=object)
for r in range(map_height):
    for c in range(map_width):
        if (r,c) in city_coords:
            tile_biomes[r,c] = 'city'
        elif pond_mask[r,c]:
            tile_biomes[r,c] = 'pond'
        else:
            tile_biomes[r,c] = classify_biome(noise[r,c])
        tile_closed_edges[r,c] = get_closed_edges(tile_biomes[r,c])

# Render the map
fig, ax = plt.subplots(figsize=output_size)
ax.set_aspect('equal')
placed_cities = []

for r in range(map_height):
    for c in range(map_width):
        center = hex_coordinates(r, c, hex_radius)
        biome = tile_biomes[r, c]
        fill_color = biomes[biome]['color']
        red_edge = list(tile_closed_edges[r, c])[0] if len(tile_closed_edges[r, c]) > 0 else None

        # Base hex with full black outline
        ax.add_patch(RegularPolygon(
            xy=center, numVertices=6, radius=hex_radius,
            orientation=np.radians(30), facecolor=fill_color, edgecolor='black', linewidth=1
        ))

        # Overdraw red edge to simulate variant
        if red_edge is not None:
            start, end = edge_to_vertices(center, hex_radius, red_edge)
            ax.add_line(Line2D([start[0], end[0]], [start[1], end[1]], color='red', linewidth=2))

        # City label
        if biome == 'city':
            name = city_names[city_coords.index((r, c))]
            ax.text(center[0], center[1], name, fontsize=6, color='white',
                    ha='center', va='center', fontweight='bold')

# Compass
arrow_x, arrow_y = hex_coordinates(1, map_width - 3, hex_radius)
ax.add_patch(FancyArrowPatch((arrow_x, arrow_y), (arrow_x, arrow_y + 1.5),
                             mutation_scale=20, color='black'))
ax.text(arrow_x, arrow_y + 1.6, 'N', ha='center', va='bottom', fontsize=12, fontweight='bold')

# Legend
legend_handles = [mpatches.Patch(color=biomes[k]['color'], label=k.capitalize())
                  for k in ['plains', 'forest', 'mountains', 'pond', 'city']]
ax.legend(handles=legend_handles, loc='upper right')

# Axes limits
xmin, ymin = 0, 0
xmax, ymax = hex_coordinates(map_height - 1, map_width - 1, hex_radius)
ax.set_xlim(xmin - 2, xmax + 2)
ax.set_ylim(ymin - 2, ymax + 4)

# Save output
ax.axis('off')
plt.savefig(output_filename, dpi=output_dpi, bbox_inches='tight')
plt.close()
print(f"Map saved as '{output_filename}'")
